#+title: srxl's Emacs Configuration
#+author: Ruby Iris Juric
#+email: ruby@srxl.me
#+description: My personal Emacs configuration, as a Literate Org-Mode document
#+startup: overview indent
#+property: header-args :noweb no-export

Hello, reader.

Welcome to my Emacs configuration.

You're probably here because you wish to glean knowledge of the arcane and eldritch arts of the almighty Emacs Text Editing, List Processing, Electronic-Mail Reading, Tetris Playing Realm... or something like that.

Or you're me. Could be that too.

Either way, no matter what brings you here, I hope you find whatever it was that your soul was searching for.

Maybe you find something you didn't even know you wanted. If so, awesome!

Maybe this is useless to you. That's cool too. First step to knowing what you need, is knowing what you don't need.

Pretty sure some old wise guy said that at some point.

Or maybe I'm making this up. I don't know.

Maybe I should get on with the actual config. Yeah, good idea. Let's do that.

* The basics
** In the beginning...
Alright, let's start by getting the very basics down. We'll start by enabling [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][lexical binding]] for this file, so that we avoid any Certified Weirdness that comes with dynamic binding.
#+begin_src emacs-lisp :tangle yes
  ;;; config.el -*- lexical-binding: t -*-
#+end_src

Cool. Now, in case you didn't know, I use [[https://nixos.org/][NixOS]] as my operating system, and I have a [[https://github.com/Sorixelle/dotfiles/][hella fancy setup]] for managing every single little piece of my machines. Including Emacs. I've written a [[https://github.com/Sorixelle/dotfiles/blob/master/home/modules/emacs.nix][cool little module]] to expose some parts of that configuration to Emacs in the form of an additional variables file. Let's load that in now.
#+begin_src emacs-lisp :tangle yes
  (load-file (concat user-emacs-directory "config-vars.el"))
#+end_src

** Setting expectations
Ok, let's start actually setting some Emacs options. First thing we'll do is disable the startup splash and clear the scratch buffer. We want a clean slate when we start up.
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-startup-screen t
        initial-scratch-message nil)
#+end_src

Next, let's change every "yes or no" prompt to be "y or n". Less typing for me. Oh, and don't make graphical popups for those. I'd rather not use my mouse, thanks.
#+begin_src emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq use-dialog-box nil)
#+end_src

Now that we have that, we'll ask one of those questions whenever we go to close Emacs. Can never be too safe.
#+begin_src emacs-lisp :tangle yes
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Let's get rid of those gaudy UI elements. Who needs a toolbar or a scrollbar when you have a keyboard and every keybinding you could ever want?
#+begin_src emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (fringe-mode 1)
#+end_src

We'll start up all Emacs windows fullscreen, so that we have as much space as possible to wreak havoc on the world. Or at least write some words in a file.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

While we're doing windows - opening a file in macOS from the Finder seems to always create a new frame, which is really annoying. Stop doing that.
#+begin_src emacs-lisp :tangle yes
  (when (eq window-system 'ns)
    (setq ns-pop-up-frames nil))
#+end_src

Automatically reload buffers when their underlying files change on the disk, when other rude tools start yanking the carpet from under me.
#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
#+end_src

Make sure all code files have their syntax highlighting enabled.
#+begin_src emacs-lisp :tangle yes
  (global-font-lock-mode 1)
#+end_src

Crank up Emacs' garbage collection limit to 20MB, so it doesn't run as often.
#+begin_src emacs-lisp :tangle yes
  (setq gc-cons-threshold 20000000)
#+end_src

Don't open the Warnings buffer whenever there's a native compilation warning. It's annoying and gets in my face.
#+begin_src emacs-lisp :tangle yes
  (setq native-comp-async-report-warnings-errors 'silent)
#+end_src

Write customizations to it's own, dedicated file. Writing to =init.el= isn't going to fly under NixOS, since it manages that file with a symlink.
#+begin_src emacs-lisp :tangle yes
  (setq custom-file (concat user-emacs-directory "customizations.el"))
  (load-file custom-file)
#+end_src

And, last but not least... STOP MAKING NOISES
#+begin_src emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
#+end_src

** File editing bits and bobs
Trailing whitespace is yucky. Except for trailing newlines at the end of a file though - those are good. We want those. Let's make that happen.
#+begin_src emacs-lisp :tangle yes
  (setq require-final-newline 'visit-save)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Backups and auto-save files are an absolute godsend. They've saved my ass /so/ many times. But the default behaviour of just cramming them next to the actual file is really annoying, especially for version control. We'll adjust their behaviour a little bit, so that:

- Backup files go to =~/.emacs.d/backups=
- Autosave files go to =~/.emacs.d/auto-saves=
- Some extra options are tweaked (see comments)
#+begin_src emacs-lisp :tangle yes
  (setq backup-by-copying t    ; Keep symlinks intact
        version-control t      ; Make sure backups are numbered
        delete-old-versions t  ; Always delete old backups
        kept-new-versions 10   ; Keep the last 10 backups
        kept-old-versions 0    ; Don't worry about keeping initial ones
        auto-save-interval 50) ; Autosave every 50 characters typed

  (let ((backup-dir (concat user-emacs-directory "backups/"))
        (auto-save-dir (concat user-emacs-directory "auto-saves/"))
        (max-file-size (* 5 1024 1024))) ; 2 MB
    (if (not (file-exists-p backup-dir))
        (make-directory backup-dir))
    (if (not (file-exists-p auto-save-dir))
        (make-directory auto-save-dir))
    (setq backup-directory-alist `(("" . ,backup-dir))
          auto-save-file-name-transforms `((".*" ,auto-save-dir t))))
#+end_src

Lockfiles though - those suck. I don't need those. Go away. You smell.
#+begin_src emacs-lisp :tangle yes
  (setq create-lockfiles nil)
#+end_src

Typing over text doesn't really work the way you'd expect it to in Emacs by default, but luckily there's a minor mode to fix that.
#+begin_src emacs-lisp :tangle yes
  (delete-selection-mode 1)
#+end_src

Single space after full stops. Come on. Why isn't this the default?
#+begin_src emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)
#+end_src

Indent with spaces, not tabs. Come on. Why isn't this the default?
#+begin_src emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
#+end_src

2 space indents. Come on. Why isn't thi
#+begin_src emacs-lisp :tangle yes
  (setq-default tab-width 2)
#+end_src

Default line length is 80 characters. Wrap lines to that length.
#+begin_src emacs-lisp :tangle yes
  (setq-default fill-column 80)
#+end_src

** Package preparation
There are much smarter people out there, who can write way better and much cooler stuff with Emacs than I can. We can ~steal~ leverage their work through the help of a package manager. My package manager of choice is [[https://github.com/raxod502/straight.el][straight.el]]. I like it for a few reasons:

- Grabs packages straight from Git, so I have the latest and greatest versions
- Loads packages declaratively - don't load anything I don't tell it to
- Lets me hack on packages if I need to, and I often find myself needing to

Let's set it up. I'll pinch that little block from their repo's README.
#+begin_src emacs-lisp :tangle yes
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

While we're here, let's bring in another cool tool for managing packages: [[https://github.com/jwiegley/use-package][use-package]]. This little macro is wonderful for organizing package configuration in once central place. It's even got integration with straight.el, so it can install the packages too.
#+begin_src emacs-lisp :tangle yes
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

And while we're here, let's set up our first package - [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]. This ensures that =exec-path= is correctly setup on macOS, because macOS is really dumb and stupid and doesn't know what it's doing.
#+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :custom
    (exec-path-from-shell-variables '("PATH" "MANPATH" "NIX_PATH"))
    :config
    (exec-path-from-shell-initialize))
#+end_src

* Moving around and doing things
** A heretical interface
I love Vim keybindings. Modal editing just makes so much sense to me. Being able to yank lines, move between words, easily navigate through my documents with simple, (usually) mnemonic keybindings feels so nice. Over here in Emacs-land, we've got a package aptly titled [[https://github.com/emacs-evil/evil][Evil]]... y'know, because Vim keybindings... editor holy wars... Vim is evil if you're in the Emacs camp...

Meh, whatever. Let's get it set up.
#+begin_src emacs-lisp :tangle yes
  (use-package evil
    :init
    <<EVIL-INIT>>
    :config
    <<EVIL-CONFIG>>)
#+end_src

First thing that needs to be done, is enabling =evil-mode=. That'll get us all our keybindings active.
#+begin_src emacs-lisp :noweb-ref EVIL-CONFIG
  (evil-mode 1)
#+end_src

We'll also add [[https://github.com/emacs-evil/evil-collection][evil-collection]], which extends Evil's keybindings to a few other modes and extra packages.
#+begin_src emacs-lisp :tangle yes
  (use-package evil-collection
    :config
    (evil-collection-init)
    <<EVILCOLLECTION-CONFIG>>)
#+end_src

But first - evil-collection requires =evil-want-keybinding= to be set to =nil= before Evil is loaded.
#+begin_src emacs-lisp :noweb-ref EVIL-INIT
  (setq evil-want-keybinding nil)
#+end_src

Tell evil-collection NOT to eat my =TAB= binding in Outline mode (and Org mode by extension).
#+begin_src emacs-lisp :noweb-ref EVILCOLLECTION-CONFIG
  (setq evil-collection-outline-bind-tab-p t)
#+end_src

** Managing the keyboard buttons
The keyboard is the best interface to Emacs. Keybindings can do everything. Although, managing keybindings can be a bit tricky. Luckily, [[https://github.com/noctuid/general.el][general.el]] has us covered there. General provides a nice interface for managing keybindings, especially when it comes to things like enabling bindings only in certain Evil states.
#+begin_src emacs-lisp :tangle yes
  (use-package general)
#+end_src

We're going to use the same =SPC= leader key pattern that Emacs frameworks like Doom and Spacemacs use - I'm a fan of it, makes things really easy to access while working in a project buffer. Less having to hold =C-whatever= as well, which is always nice. Using General, which we setup earlier, we can make a /definer/ function, that acts as a shortcut to adding keys under a prefix, and in specific Evil states.
#+begin_src emacs-lisp :tangle yes
  (general-create-definer srxl/def-leader-key
    :states '(normal motion emacs)
    :prefix "SPC"
    :prefix-map 'srxl/leader-key-map)
#+end_src

One thing to note though - Evil's motion state defines =SPC= as moving point forward, which conflicts with this leader key definition. We'll have to remove that before we can get anywhere.
#+begin_src emacs-lisp :tangle yes
  (general-unbind 'motion "SPC")
#+end_src

Finding all these keybindings can be a pain. Luckily we have [[https://github.com/justbur/emacs-which-key][which-key]] to help us with that. It shows us a list of all avaliable commands when we hit a prefix, such as =C-c=. Useful for identifying just what the hell the "switch buffer" command is. Was is =C-c C-b=? =C-c b=? Some other insane combination? I don't know, you tell me.
#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :config
    (which-key-mode 1))
#+end_src

** Window navigation
Why should I limit myself to just one file at a time? Why not view as many as I want? That's what windows are for. Not to be confused with the frame (ie. the Emacs application window), windows subdivide the screen into multiple sections, each displaying it's own buffer.

For most window operations, Evil already has us covered, with a bunch of useful keybindings tucked away under =C-w=. But that's not enough for me. A multi-key =C-w=-prefixed action can get a bit annoying when traversing across a few windows. =ace-window= is a tool that comes in really handy for these situations - when you activate it, it numbers every window, and you just need to press that number to jump to that window. Simple simple. We'll bind it to =SPC w=.
#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :config
    (srxl/def-leader-key
      "w" '(ace-window :wk "Switch window")))
#+end_src

And now that we have window management down, we also should have a good way to change their buffers. =SPC b= will do just fine for that - we'll even use the Consult-enhanced version (we'll get to what Consult is in a moment...) which previews the buffer as we flip through the list.
#+begin_src emacs-lisp :tangle yes
  (srxl/def-leader-key
    "b" '(consult-buffer :wk "Switch buffer"))
#+end_src

** Searching and completing and filtering and
So, you expect me to just hit =M-x=, and know the exact name of the thing I'm looking for? Yeah, alright. I'm clueless. I don't know what things are called. Besides, even if I did, that's way too much typing. If only there was an autocompletion framework out there to make this easier...

Ok, ok. It's called [[https://github.com/minad/vertico][Vertico]]. It gives me a really nice, simple and lightweight autocompletion system for any =completing-read= task I may need.
#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :init
    (vertico-mode 1)
    <<VERTICO_CONF>>
    (setq enable-recursive-minibuffers t))
#+end_src

Pretty good out of the box - we'll just chuck in some more keybinds for moving up and down the list with =M-k= and =M-j= respectively.
#+begin_src emacs-lisp :noweb-ref VERTICO_CONF
  (general-def 'vertico-map
    "M-k" 'vertico-previous
    "M-j" 'vertico-next)
#+end_src

For some extra fancy minibuffer action, [[https://github.com/minad/consult][Consult]] gives some extra commands with souped-up versions of default stuff.
#+begin_src emacs-lisp :tangle yes
  (use-package consult
    :config
    <<CONSULT_CONF>>)
#+end_src

=consult-line= gives a really nice way to search text in files. We'll override Evil's default =/= binding with it.
#+begin_src emacs-lisp :noweb-ref CONSULT_CONF
  (general-def '(normal motion)
    "/" 'consult-line)
#+end_src

[[https://github.com/oantolin/orderless][Orderless]] is a really neat and unique way to manage completions - it's like regex, initialisms, literals, and inverted matches all in one! Dunno how they did that, but I'm a fan.
#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '(file (styles basic partial-completion))))
#+end_src

And for some extra info in completions (when there is info, of course) - [[https://github.com/minad/marginalia][Marginalia]] provides completions with some extra info, like function documentations, to help quickly grok your options.
#+begin_src emacs-lisp :tangle yes
    (use-package marginalia
      :init
      (marginalia-mode 1)
      <<MARGINALIA_CONF>>)
#+end_src

Sometimes, there's multiple things Marginalia can display - we can cycle between them with a keybind. We'll use =M-a=.
#+begin_src emacs-lisp :noweb-ref MARGINALIA_CONF
  (general-def 'minibuffer-local-map
    "M-a" 'marginalia-cycle)
#+end_src

* ✨aesthetics✨
If I'm going to use Emacs as much as I do, I want to use something that's actually nice to look at. Default Emacs might be nice to some people... but not to me. Time to fix that up.

** Pretty letters
We'll start off by setting some nicer fonts. That's one of the things that's a part of my NixOS config, so we'll read the variables set from there.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'default-frame-alist `(font . ,(concat srxl/font-family-monospace " " srxl/font-size-monospace)))
  (set-face-attribute 'variable-pitch nil :family srxl/font-family-ui :height srxl/font-size-ui)
  (set-face-attribute 'fixed-pitch nil :family srxl/font-family-monospace :height (* 10 (string-to-number srxl/font-size-monospace)))
#+end_src

We're also going to define a face for a serif font. This'll get used later, for stuff like Org mode.
#+begin_src emacs-lisp :tangle yes
  (defface serif
    `((t (:inherit variable-pitch :family ,srxl/font-family-serif :height ,srxl/font-size-serif)))
    "Serif font.")
#+end_src

Make sure emoji get the full colour treatment on Linux.
#+begin_src emacs-lisp :tangle yes
  (when (not (memq window-system '(mac ns)))
    (set-fontset-font t 'emoji "Noto Color Emoji"))
#+end_src

** Pretty colours
Default emacs burns my eyes. /hiss/. I'll take a nicer theme, thanks.

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] has a bunch of good ones. Implementations for basically every common colour scheme under the sun like Monokai, Solarized, Dracula, and then some.
#+begin_src emacs-lisp :tangle yes
  (use-package all-the-icons)
  (use-package doom-themes
    :config
    <<DOOMTHEMES-CONFIG>>)
#+end_src

[[https://github.com/protesilaos/modus-themes][modus-themes]] also has some really nice themes that I sometimes use. It's shipped default in Emacs, but the very latest changes bring in some cool stuff that aren't upstreamed yet in all but the very bleeding edge of Emacs. So we'll pull down the latest version, just to be safe.
#+begin_src emacs-lisp :tangle yes
  (use-package modus-themes)
#+end_src

[[https://github.com/catppuccin/emacs][Catppuccin]] is another really nice one.
#+begin_src emacs-lisp :tangle yes
  (use-package catppuccin-theme)
#+end_src

But which one do I use? That's defined in my NixOS configuration. Go check that out if you really wanna know. In any case, it'll get enabled here.
#+begin_src emacs-lisp :tangle yes
  (load-theme srxl/theme-name t)
#+end_src

The tree-sitter modes have an option to set the amount of different things to colorize. I think it looks best with that setting cranked all the way up.
#+begin_src emacs-lisp :tangle yes
  (setq treesit-font-lock-level 4)
#+end_src

** Pretty modeline
The mode line in Emacs is that little line at the bottom of the window that has all the status stuff, like filename... uh... man, the default mode line doesn't really have a lot of useful stuff in it, huh? Hmm.

I'm far too lazy to write my own mode line. Luckily, multiple people have done it for me, and I just need to pick the one I like. And I like [[https://github.com/seagle0128/doom-modeline][doom-modeline]]. It's got everything I could possibly want in a modeline, and it looks cool to boot. Let's get it going.
#+begin_src emacs-lisp :tangle yes
  (use-package nerd-icons)
  (use-package doom-modeline
    :config
    <<DOOMLINE-CONFIG>>)
#+end_src

Make the modeline nice and thick.
#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (setq doom-modeline-height 32)
#+end_src

Enable =column-number-mode= so that we can get column number displayed in the modeline, along with the line number.
#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (column-number-mode 1)
#+end_src

And enable =display-time-mode= for a clock in there as well.
#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (display-time-mode 1)
#+end_src

And activate.
#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (doom-modeline-mode 1)
#+end_src

* Emacs, my favourite word processor
[[https://orgmode.org/][org-mode]] might just be one of the most amazing programs ever made. Like, seriously. This thing is amazing. It's a markup language, a todo list, a calendar, a spreadsheet, Jupyter Notebook on sterioids... I could keep going on here, but that's probably not what you're here for. You're here to see me configure this delightful thing. And I'm not about to waste anymore time.
#+begin_src emacs-lisp :tangle yes
  (use-package org
    :config
    <<ORG-CONFIG>>)
#+end_src

** Making documents look pretty
Monospaced text just doesn't quite do org-mode justice. This isn't code (well, not entirely) - it's a document! Let's make it look like one by using a fancy serif font. Check the NixOS config for which specific one it is.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-hook 'org-mode-hook (lambda () (progn
                                        (setq-local buffer-face-mode-face 'variable-pitch)
                                        (buffer-face-mode 1))))
#+end_src

Code should probably still be monospace though. That makes sense.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
#+end_src

So should tables, otherwise they look all ugly and misaligned.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+end_src

Make headings look a little prettier with [[https://github.com/sabof/org-bullets][org-bullets]].
#+begin_src emacs-lisp :tangle yes
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+end_src

And make them a bit more distinct at each level, by setting different sizes for them.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-document-title nil :height 1.5)
  (set-face-attribute 'org-level-1 nil :height 1.5)
  (set-face-attribute 'org-level-2 nil :height 1.25)
  (set-face-attribute 'org-level-3 nil :height 1.125)
  (set-face-attribute 'org-level-4 nil :height 1.1)
#+end_src

Sometimes, lines get pretty long in Org documents. Visual Line mode will make sure they wrap around and don't fly way off the edge of the screen.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

Enable visual indentation when viewing files, for a little extra visual separation between headers.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (setq org-startup-indented t)
#+end_src

Don't worry about showing the symbols around things like *bold*, /italic/ or =inline code=.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (setq org-hide-emphasis-markers t)
#+end_src

But add a function and a keybinding to toggle them, in case we want them.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (defun srxl/org-toggle-emphasis-markers ()
    "Toggle the visibility of emphasis markers in Org mode buffers."
    (interactive)
    (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
    (font-lock-fontify-buffer))

  ;; TODO: finalize binding
  (general-def 'org-mode-map
    "C-c t" 'srxl/org-toggle-emphasis-markers)
#+end_src

doom-themes from earlier includes some stuff to tidy up Org visuals a little bit.
#+begin_src emacs-lisp :noweb-ref DOOMTHEMES-CONFIG
  (doom-themes-org-config)
#+end_src

** Editing trickery
As part of writing these documents, I create a lot of emacs-lisp source blocks in Org. Like, a lot. A faster way to create those is definitely in order. Luckily, =org-structure-template-alist= comes in handy for us to add whatever shortcust we want for producing blocks. Let's add a shortcut for making an emacs-lisp source block.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
#+end_src

To make things even faster, we can use Org Tempo to summon a block, just by typing =<el= and hitting TAB.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (require 'org-tempo)
#+end_src

** Keeping notes and tracking knowledge
With Org documents being such a great way to structure text, why not use them to create my own personal wiki? Just have a bunch of notes on whatever subject I can pull up to reference and add to any time I want. Sounds great to me. We can use [[https://orgroam.com][org-roam]] to facilitate this - it creates a database of Org documents that can be linked together and easily sorted by topic.
#+begin_src emacs-lisp :tangle yes
  (use-package org-roam
    :straight nil
    :config
    <<ORG-ROAM-CONFIG>>)
#+end_src

We need a directory to stash all our notes away in, so let's make sure that exists and tell org-roam what it is.
#+begin_src emacs-lisp :noweb-ref ORG-ROAM-CONFIG
  (if (not (file-exists-p srxl/roam-dir))
      (make-directory srxl/roam-dir))
  (setq org-roam-directory srxl/roam-dir)
#+end_src

There's some periodic jobs that need to be run to ensure the org-roam database is kept up to date - =org-roam-db-autosync-mode= will make sure those fire off when they need to.
#+begin_src emacs-lisp :noweb-ref ORG-ROAM-CONFIG
  (org-roam-db-autosync-mode)
#+end_src

We can leverage the built-in Emacs SQLite support, if we configure it correctly.
#+begin_src emacs-lisp :noweb-ref ORG-ROAM-CONFIG
  (setq org-roam-database-connector 'sqlite-builtin)
#+end_src

We can setup capture templates in Org-Roam to file notes into specific directories, define initial content - a bunch of stuff. I've got a few templates I want to use when capturing a new note:
- General :: Unspecific, general-purpose notes that don't have any particular reference, other than the notes they link to.
- Reference :: Notes taken from some reference material, such as a website or a textbook.
- Private :: Like General, but PGP-encrypted, for storing any notes with sensitive information.

#+begin_src emacs-lisp :noweb-ref ORG-ROAM-CONFIG
  (setq org-roam-capture-templates '(("g" "General" plain "%?"
                                      :target (file+head "general/${slug}.org"
                                                         "#+title: ${title}\n\n")
                                      :unnarrowed t)
                                     ("r" "Reference" plain "%?"
                                      :target (file+head "references/${slug}.org"
                                                         "#+title: ${title}\n\n")
                                      :unnarrowed t)
                                     ("p" "Private" plain "%?"
                                      :target (file+head "private/${slug}.org.gpg"
                                                         "#+title: ${title}\n\n")
                                      :unnarrowed t)))
#+end_src

There's no keybindings by default. We probably want some.
#+begin_src emacs-lisp :noweb-ref ORG-ROAM-CONFIG
  (srxl/def-leader-key
    "n"   '(:ignore t :wk "Notes")
    "n f" '(org-roam-node-find :wk "Find note")
    "n l" '(org-roam-node-insert :wk "Insert link to note")
    "n c" '(org-roam-capture :wk "Capture note")
    "n r" '(org-roam-ref-add :wk "Add reference"))
#+end_src

* Emacs, my favourite email client
Email is so cool. It's such a ubiquitous way to communicate with people. Everyone has an email address. I have an email address. I also have an Emacs. Why don't I put the E-Mail in the E-Macs? Sounds like a no brainer to me. mu4e, let's do it.

We've got =:straight nil= in this one because mu4e comes with the mu package, not from some external package repo. We don't want straight trying to pull down whatever it finds in repos, we just want to make it look in the existing load path.
#+begin_src emacs-lisp :tangle yes
  (use-package mu4e
    :if srxl/use-mu4e
    :straight nil
    :config
    <<MU4E-CONFIG>>)
#+end_src

We'll set =user-mail-address= and =user-full-name= so things know to use the right email. That email comes from my NixOS configuration.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (setq user-mail-address srxl/email
        user-full-name "Ruby Iris Juric")
#+end_src

I use =mbsync= to copy my emails from IMAP to a Maildir directory, so we'll setup mu4e to use that.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (setq mu4e-get-mail-command "mbsync -a"
        mu4e-change-filenames-when-moving t)
#+end_src

Make sure mu4e points itself at the right folder names for standard email folders.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (setq mu4e-sent-folder "/Sent"
        mu4e-drafts-folder "/Drafts"
        mu4e-trash-folder "/Trash"
        mu4e-refile-folder "/Archive")
#+end_src

Synchronize my emails automatically every 5 minutes.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (setq mu4e-update-interval (* 5 60))
#+end_src

Use SMTP sendmail for sending emails.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (setq send-mail-function 'sendmail-send-it)
#+end_src

And a keybind to quickly pop open the client.
#+begin_src emacs-lisp :noweb-ref MU4E-CONFIG
  (srxl/def-leader-key
    "e" '(mu4e :wk "Email"))
#+end_src
* Emacs, my favourite IDE
Yeah, this is the one everyone knows Emacs for. Code editor! That's the main one everyone uses Emacs for. And for good reason - it does a damn good job of editing code. Although, it does need a little assistance to get it off the ground in that regard. Let's give it a hand.

** General
First, a few general bits and pieces that we want to have when editing code.

Show line numbers in all code files. Pretty much every programming mode derives from =prog-mode=, so we can hook into that.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook (lambda () (setq-local display-line-numbers t)))
#+end_src

Keeping things like quotation marks for strings, and parentheses balanced is really important for code edititng. [[https://github.com/Fuco1/smartparens][Smartparens]] is a good option for this. So we'll use it.
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :config
    (require 'smartparens-config)
    (smartparens-global-mode))
#+end_src

Some expansions by default are a little odd. To explain what I mean, I'll demonstrate with a text example, where =|= is the position of the cursor before and after hitting =RET=:

#+begin_example
  {|}
  -----
  {
  |}
#+end_example

It's a little weird, isn't it? I'd expect something a little more like:

#+begin_example
  {|}
  -----
  {
    |
  }
#+end_example

Much more reasonable, yeah? Luckily, we can write a function to fix this for us. Smartparens lets us hook into it's insertions, and trigger functions after them. We'll first write a function that will do the newline insertion and indentation we need.

#+begin_src emacs-lisp :tangle yes
  (defun srxl/newline-indent (&rest _)
    "Insert a newline, and correct surrounding indentation."
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))
#+end_src

Now, we can add another function to fixup this indentation behaviour for the modes and characters we want it in. It'll fire that function we just called after hitting =RET=.

#+begin_src emacs-lisp :tangle yes
  (defun srxl/fix-brace-indentation (mode &rest chars)
    "Adjust Smartparens brace insertion hook for CHARS in MODE."
    (dolist (char chars)
      (sp-local-pair mode char nil :post-handlers '((srxl/newline-indent "RET")))))
#+end_src

** Autocomplete
First off, let's get some autocomplete capability in here. We gotta have that - what's an IDE without autocomplete? Although, this doesn't provide language-specific completions, just the UI for autocompletion. We'll get to that in a bit.

[[https://github.com/minad/corfu][Corfu]] is a super neat little library that builds off =completion-at-point= to provide a nice little autocomplete box. We add the extensions to the load path, since they're not in there by default and we want to use some of them.
#+begin_src emacs-lisp :tangle yes
  (use-package corfu
    :load-path "straight/repos/corfu/extensions"
    :config
    <<CORFU-CONFIG>>)
#+end_src

Like most editors, we want the autocomplete options to appear right after we've finished typing, without a delay. We don't want it to appear until we've typed at least 1 character though, otherwise it'll pop up at some points where we want to use =RET= to insert a newline. And that's no fun.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-auto t
        corfu-auto-delay 0
        corfu-auto-prefix 1)
#+end_src

We also want to cycle back to the top of the list if we try to go past the end.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-cycle t)
#+end_src

Don't select any completion by default...
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-preselect-first nil)
#+end_src

...because we want to hit Tab to cycle through completions, and just fill the one we land on.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (general-def 'corfu-map
    "TAB" 'corfu-next
    [tab] 'corfu-next
    "S-TAB" 'corfu-previous
    [backtab] 'corfu-previous)
#+end_src

Being able to see the documentation of items I've selected is nice. Corfu's built-in popupinfo extension can do that for us.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (require 'corfu-popupinfo)
  (add-hook 'corfu-mode-hook 'corfu-popupinfo-mode)
#+end_src

[[https://github.com/jdtsmith/kind-icon][kind-icon]] is another package that will give us little icons next to competions, kinda like how VSCode does it. It looks pretty. I like it.
#+begin_src emacs-lisp :tangle yes
  (use-package kind-icon
    :config
    <<KIND-ICON-CONFIG>>)
#+end_src

Set the default face for icons to be the one corfu uses, so that kind-icon can compute it's background colours correctly.
#+begin_src emacs-lisp :noweb-ref KIND-ICON-CONFIG
  (setq kind-icon-default-face 'corfu-default)
#+end_src

Tell Corfu to use kind-icon.
#+begin_src emacs-lisp :noweb-ref KIND-ICON-CONFIG
  (add-to-list 'corfu-margin-formatters 'kind-icon-margin-formatter)
#+end_src

Aaaaaaaaand enable.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (global-corfu-mode 1)
#+end_src

** Project management
When I'm working in projects, having some keybinds and commands to quickly get around and run some local dev servers or whatever is really useful. [[https://docs.projectile.mx/projectile/index.html][Projectile]] gives a whole lot of that.
#+begin_src emacs-lisp :tangle yes
  <<projectile-pre>>
  (use-package projectile
    :config
    <<projectile-config>>
    (projectile-mode 1))
#+end_src

Projectile is able to use ripgrep to search in projects, which is awesome - with the caveat that we need to bring in a supporting package.
#+begin_src emacs-lisp :tangle yes
  (use-package rg
    :after projectile)
#+end_src

And also with the caveat that it needs to run in a POSIX-compliant shell. I use Fish on most of my machines, so that's not gonna fly. We'll make sure Emacs uses a standard shell instead.
#+begin_src emacs-lisp :noweb-ref projectile-pre
  (setq shell-file-name "/bin/sh")
#+end_src

I generally tend to keep all my projects in a single folder. Since that can be different on different machines, it's defined in =config-vars.el=. Giving that path to Projectile can help it to auto-detect projects.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (setq projectile-project-search-path (list srxl/project-dir))
#+end_src

When calling functions that run project commands, like =projectile-compile-project=, Projectile shows the command's output in a Compilation Mode buffer. By default, it doesn't handle ANSI colors correctly, but there's a function we can add to =compilation-filter-hook= to do this for us.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+end_src

And now, keybindings.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (srxl/def-leader-key
    "s" '(projectile-switch-project :wk "Switch project")
    "f" '(projectile-find-file :wk "Find file")
    "x" '(projectile-kill-buffers :wk "Close project")
    "/" '(projectile-ripgrep :wk "Grep project")

    "r" '(:ignore t :wk "Run command...")
    "r b" '(projectile-package-project :wk "Build")
    "r c" '(projectile-compile-project :wk "Compile")
    "r i" '(projectile-install-project :wk "Install")
    "r s" '(projectile-configure-project :wk "Configure")
    "r t" '(projectile-test-project :wk "Test"))
#+end_src

Other bindings will be coming in the following sections.

** File exploring
Next, we'll get outselves a file explorer, by way of [[https://github.com/Alexander-Miller/treemacs][Treemacs]]. It's a fully-featured file tree sidebar, just like you'd have in every IDE.

The project follow mode seems to have some issues with byte compilation, so we won't byte-compile Treemacs.
#+begin_src emacs-lisp :tangle yes
  <<TREEMACS-PRE>>
  (use-package treemacs
    :straight (:build (:not compile))
    :custom
    <<TREEMACS-CUSTOM>>
    :config
    <<TREEMACS-CONFIG>>)
#+end_src

Grab the Evil extensions, otherwise navigating through that tree is gonna be no fun at all.
#+begin_src emacs-lisp :tangle yes
  (use-package treemacs-evil)
#+end_src

Ensure that Treemacs follows the project we're currently in. I don't have much use for the workspaces feature it provides - I prefer to work in one project at a time.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-project-follow-mode 1)
#+end_src

Watch for filesystem changes.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-filewatch-mode 1)
#+end_src

Colour nodes in the tree based on Git status.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-git-mode 'deferred)
#+end_src

Set the default file opening behaviour to open the file in the last visited window.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CUSTOM
  (treemacs-default-visit-action 'treemacs-visit-node-in-most-recently-used-window)
#+end_src

doom-themes has some nice icon themes for Treemacs. We'll use those icons.
#+begin_src emacs-lisp :noweb-ref DOOMTHEMES-CONFIG
  (setq doom-themes-treemacs-theme "doom-atom")
  (doom-themes-treemacs-config)
#+end_src

Bind =SPC .= to toggle Treemacs on and off.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (srxl/def-leader-key
    "." '(treemacs :wk "Toggle Treemacs"))
#+end_src

I'm not a fan of having Treemacs open all the time. It takes up space when I'm editing files, and I end up using my mouse to navigate between files more often than I'd like when it's left open. To solve this, we'll first define a helper function to close the Treemacs window if it's opened.
#+begin_src emacs-lisp :noweb-ref TREEMACS-PRE
  (defun srxl/close-treemacs-if-open (&rest _)
    "Close the Treemacs window if it is open. Otherwise, do nothing."
    (when-let (win (treemacs-get-local-window))
      (delete-window win)))
#+end_src

Then, we'll add advice to the =treemacs-visit= class of functions, so that the window gets closed when a file is selected. Much cleaner view for code editing.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (advice-add 'treemacs-visit-node-in-most-recently-used-window :after 'srxl/close-treemacs-if-open)
  (advice-add 'treemacs-visit-node-vertical-split :after 'srxl/close-treemacs-if-open)
  (advice-add 'treemacs-visit-node-horizontal-split :after 'srxl/close-treemacs-if-open)
#+end_src

** Version control
Remember how I said org-mode might be one of the best programs ever made? [[https://magit.vc/][Magit]] is like, tied. At least second place. Magit is, without a doubt, the single most comprehensive Git interface I have ever seen. I haven't found a task I can't do in Magit yet. It's amazing. Seriously, if you use Emacs, and manage Git projects, but aren't using Magit, you're missing out big time.
#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :config
    <<MAGIT-CONFIG>>)
#+end_src

Open the Magit interface with =SPC v=.
#+begin_src emacs-lisp :noweb-ref MAGIT-CONFIG
  (srxl/def-leader-key
    "v" '(magit-status :wk "View Git status"))
#+end_src

Treemacs has some integration with Magit, to get the Git status highlighting of files in sync.
#+begin_src emacs-lisp :tangle yes
  (use-package treemacs-magit
    :after (treemacs magit))
#+end_src

** Integrated terminal
[[https://github.com/akermu/emacs-libvterm][emacs-libvterm]] is probably the most fully-featured terminal emulator out there. It provides a really nice integration experience with Emacs.
#+begin_src emacs-lisp :tangle yes
  (use-package vterm
    :config
    <<VTERM-CONFIG>>)
#+end_src

Use the shell-provided title in the buffer name.
#+begin_src emacs-lisp :noweb-ref VTERM-CONFIG
  (setq vterm-buffer-name-string "vterm (%s)")
#+end_src

[[https://github.com/kyagi/shell-pop-el][shell-pop]] is a tool that gives us a popup terminal that behaves a lot like the integrated one in VSCode.
#+begin_src emacs-lisp :tangle yes
  (use-package shell-pop
    :config
    <<SHELLPOP-CONFIG>>)
#+end_src

Typically, if I'm in a project, I want a terminal to open in the root of that project, not somewhere in the middle of the source code tree. We can write a function to check if we're in a project, and if so, open a project in the project root - otherwise, just use the current =default-directory=.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (defun srxl/open-vterm-in-project (&rest args)
    "Create a new vterm buffer, passing ARGS to `vterm'.

  If in a project, start the shell in `projectile-project-root'. Otherwise, start
  it in `default-directory'."
    (let ((default-directory (or (projectile-project-root) default-directory)))
      (apply 'vterm args)))
#+end_src

We'll use that function to open terminal buffers in shell-pop.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (custom-set-variables
   '(shell-pop-shell-type '("vterm" "vterm-sp" (lambda () (srxl/open-vterm-in-project "vterm-sp")))))
#+end_src

Don't forget to tell shell-pop to not automatically change to the directory of the buffer we called it from, because that screws with the function we just wrote.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (setq shell-pop-autocd-to-working-dir nil)
#+end_src

Since we had to overwrite the default shell during the Projectile setup, we'll need to restore it back to what we want for vterm and shell-pop. If it's defined in =config-vars.el=, we'll use that - otherwise just leave it alone.
#+begin_src emacs-lisp :noweb-ref VTERM-CONFIG
  (when (boundp 'srxl/shell-executable)
    (setq vterm-shell srxl/shell-executable
          shell-pop-term-shell srxl/shell-executable))
#+end_src

Use =SPC t= to open the terminal.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (srxl/def-leader-key
    "t" '(shell-pop :wk "Open terminal"))
#+end_src

** Code formatting
Always nice to keep code clean, neat and pretty looking. Running a code formatter on save is what most people do to ensure consistent formatting. [[https://github.com/radian-software/apheleia][Apheleia]] can help us do that in Emacs. Luckily, it's default collection of formatters are exactly what I prefer, so I don't need to worry about configuring it up. Just set and forget. Nice when things work out like that, isn't it?
#+begin_src emacs-lisp :tangle yes
  (use-package apheleia
    :config
    (apheleia-global-mode))
#+end_src

** Language Server Protocol
And now we get to the special sauce - LSP support. [[https://github.com/joaotavora/eglot][Eglot]] is a really cool, language-agnostic package that soups up the facilities Emacs already has for things like autocomplete (=completion-at-point=), jump to definition (=xref-find-definitions=) and diagnostics (=flymake-mode=).
#+begin_src emacs-lisp :tangle yes
  (use-package eglot)
#+end_src

If Eglot started successfully, enable flymake for the buffer.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'eglot-server-initialized-hook 'flymake-mode)
#+end_src

Some language servers (particularly ones built on Volar) are too silly to find their own copy of Typescript. No matter - shouldn't be too hard to find one, it's usually in =node_modules=. We'll write a function we can use to get a path to Typescript for the current project.
#+begin_src emacs-lisp :tangle yes
  (defun srxl/get-typescript-path ()
    "Returns the path to the Typescript install in the current project."
    (expand-file-name
     (concat (project-root (project-current)) "node_modules/typescript/")))
#+end_src

** Direnv integration
[[https://direnv.net/][Direnv]] is a really useful tool for setting environments per directory. It's a total godsend when working with Nix projects, since it means I can just =cd= into a directory and get that shell right away. =direnv-mode= provides that functionality for Emacs itself, so that it can call out to programs in a Nix shell. As a heavy Nix user, I can't live without it.
#+begin_src emacs-lisp :tangle yes
  (use-package direnv
    :config
    (direnv-mode))
#+end_src

** Languages
Now for all the language specific fun.

*** Nix
I use [[https://nixos.org/][Nix]] and NixOS extensively. Being able to declaratively manage system configurations, project environments, and even remote systems is just /so damn good/. I spend a lot of time editing Nix expressions as a result, so we should make sure Emacs gives me a good editing experience here.

[[https://github.com/NixOS/nix-mode][nix-mode]] provides syntax highlighting for Nix files. We'll also make sure Eglot gets enabled for them.
#+begin_src emacs-lisp :tangle yes
  (use-package nix-mode
    :mode "\\.nix\\'"
    :hook (nix-mode . eglot-ensure)
    :config
    (srxl/fix-brace-indentation 'nix-mode "{" "(" "["))
#+end_src

*** Web Markup
Emacs ships some basic tree-sitter powered modes for HTML and CSS. We'll make sure those are getting used.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.html\\'" . html-ts-mode))
  (add-hook 'html-ts-mode-hook 'eglot-ensure)

  (add-to-list 'auto-mode-alist '("\\.css\\'" . css-ts-mode))
  (add-hook 'css-ts-mode-hook 'eglot-ensure)
  (srxl/fix-brace-indentation 'css-ts-mode "{")
#+end_src

Make sure CSS files use 2 space indentation.
#+begin_src emacs-lisp :tangle yes
  (setq css-indent-offset 2)
#+end_src

That's the basics covered, but there's a lot of languages used on the web. Less, Sass, the infinite amount of templating frameworks every server-side MVC framework they just had to have their own one for... Surely we can't support them all, right? Maybe not all, but [[https://web-mode.org/][web-mode]] supports a hell of a lot of them.
#+begin_src emacs-lisp :tangle yes
  (use-package web-mode
    :mode ("\\.\\(?:le\\|sa\\|sc\\)ss\\'")
    :config
    <<WEB-CONFIG>>)
#+end_src

Make sure they use 2 space indentation.
#+begin_src emacs-lisp :noweb-ref WEB-CONFIG
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-style-padding 2
        web-mode-script-padding 2)
#+end_src

*** Javascript and Typescript
The lingua franca of the web. Like it or not, it's what we're stuck with, so we're gonna have to use it.

**** Javascript
For Javascript: js-ts-mode. It's built-in, and has everything we need for both plain-old Javascript and JSX files. The JS-TS part sounds a bit confusing, but TS stands for tree-sitter here, not TypeScript.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[mc]?jsx?\\'" . js-ts-mode))
#+end_src

Make sure LSP is running is JS buffers.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'js-ts-mode-hook 'eglot-ensure)
#+end_src

2 space indentation, not 4.
#+begin_src emacs-lisp :tangle yes
  (setq js-indent-level 2)
#+end_src

Add that Smartparens brace fix we defined earlier.
#+begin_src emacs-lisp :tangle yes
  (srxl/fix-brace-indentation 'js-ts-mode "{" "(" "[")
#+end_src

**** Typescript
Just like with Javascript, we've got the built-in =typescript-ts-mode= for Typescript files, and =tsx-ts-mode= for TSX. Setup works just like in JS land.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))

  (add-hook 'typescript-ts-mode-hook 'eglot-ensure)
  (add-hook 'tsx-ts-mode-hook 'eglot-ensure)

  (srxl/fix-brace-indentation 'typescript-ts-mode "{" "(" "[")
  (srxl/fix-brace-indentation 'tsx-ts-mode "{" "(" "[")
#+end_src

**** JS Frameworks
Some JS frameworks are special and have their own file types. Time to get those set up as well, I guess.

***** Vue
For Vue - [[https://github.com/AdamNiederer/vue-mode][vue-mode]]. Particularly, a fork of it that fixes support for Vue 3's =<script setup>=. Hopefully [[https://github.com/AdamNiederer/vue-mode/pull/115][the PR]] gets merged soon, but considering the commit history on that repo... I'm not holding my breath.
#+begin_src emacs-lisp :tangle yes
  (use-package vue-mode
    :mode "\\.vue\\'"
    :straight (vue-mode :type git :host github :repo "garyo/vue-mode" :branch "script-setup-support")
    :config
    <<VUE-CONFIG>>)
#+end_src

Get rid of that annoying background face. It's a byproduct of mmm-mode, which vue-mode uses to provide syntax highlighting for the different language sections of a Vue component.
#+begin_src emacs-lisp :noweb-ref VUE-CONFIG
  (add-hook 'mmm-mode-hook (lambda ()
                             (set-face-background 'mmm-default-submode-face nil)))
#+end_src

Setup LSP support using Volar. Annoyingly, Volar is a bit of a special language server, and need some extra configuration on Eglot's side to get going. I'll upstream all this to Eglot soon, don't worry.
#+begin_src emacs-lisp :noweb-ref VUE-CONFIG
  (defclass eglot-volar (eglot-lsp-server) ()
    :documentation "Volar Language Server for Vue")

  (cl-defmethod eglot-initialization-options ((server eglot-volar))
    "Required initialization options for Volar"
    `(:typescript
      (:serverPath ,(expand-file-name (concat (project-root (project-current)) "node_modules/typescript/lib/tsserverlibrary.js")))
      :languageFeatures
      (:references
       t
       :definition t
       :typeDefinition t
       :hover t
       :rename t
       :signatureHelp t
       :completion (:defaultTagNameCase "both" :defaultAttrNameCase "kebabCase")
       :documentHighlight t
       :workspaceSymbol t
       :codeAction t
       :diagnostics t)
      :documentFeatures
      (:documentSymbol t)))

  (add-to-list 'eglot-server-programs '(vue-mode . (eglot-volar "volar-server" "--stdio")))
#+end_src

***** Svelte
For Svelte, we'll just use web-mode. Told you it supports a hell of a lot of template languages. We'll do a similar thing we did for JSX/TSX so that we can distinguish a Svelte file from any old web-mode file.
#+begin_src emacs-lisp :tangle yes
  (define-derived-mode svelte-mode web-mode "Svelte")
  (add-to-list 'auto-mode-alist '("\\.svelte\\'" . svelte-mode))
#+end_src

And LSP setup.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'svelte-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '(svelte-mode . ("svelteserver" "--stdio")))
#+end_src

***** Astro
Astro is pretty simple - [[https://github.com/Sorixelle/astro-ts-mode][astro-ts-mode]]. Fun fact - I wrote this package :3
#+begin_src emacs-lisp :tangle yes
  (use-package astro-ts-mode
    :mode "\\.astro\\'"
    :config
    <<ASTRO-CONFIG>>)
#+end_src

LSP setup. This is one of the language servers that needs that Typescript path locating function we wrote earlier.
#+begin_src emacs-lisp :noweb-ref ASTRO-CONFIG
  (add-hook 'astro-ts-mode-hook 'eglot-ensure)

  (let ((opts (lambda (_) `(:typescript
                            (:tsdk ,(concat
                                     (srxl/get-typescript-path) "lib"))))))
    (add-to-list
     'eglot-server-programs
     `(astro-ts-mode . ("astro-ls" "--stdio" :initializationOptions ,opts))))
#+end_src

Apheleia tries to format Astro files with Prettier in HTML mode by default, which mangles the crap out of Astro templates. Let's make it use the correct Astro parser instead.
#+begin_src emacs-lisp :noweb-ref ASTRO-CONFIG
  (add-to-list
   'apheleia-formatters
   '(prettier-astro npx "prettier" "--stdin-filepath" filepath "--parser=astro"
                    (apheleia-formatters-indent "--use-tabs" "--tab-width" 'astro-ts-mode-indent-offset)))

  (add-to-list 'apheleia-mode-alist '(astro-ts-mode . prettier-astro))
#+end_src

Same brace indentation fix as per usual.
#+begin_src emacs-lisp :noweb-ref ASTRO-CONFIG
  (srxl/fix-brace-indentation 'astro-ts-mode "{" "(" "[")
#+end_src
*** BEAM (Erlang/Elixir)
The land of just letting it fail.

**** Elixir
Erlang with a modern flair.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.exs?\\'" . elixir-ts-mode))
  (add-to-list 'auto-mode-alist '("mix\\.lock\\'" . elixir-ts-mode))

  (add-hook 'elixir-ts-mode-hook 'eglot-ensure)
#+end_src

Nix's packaged Elixir language server renames the binary to a much more sane =elixir-ls= instead of the weird =language-server.sh=. We'll need to let Eglot know about that difference though.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'eglot-server-programs '(elixir-ts-mode "elixir-ls"))
#+end_src

A few Elixir frameworks like Phoenix use HEEx, an Elixir-based HTML templating language. There's a mode for that, so we'll make sure it's setup.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.heex\\'" . heex-ts-mode))
  (add-hook 'heex-ts-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '(heex-ts-mode "elixir-ls"))
#+end_src

*** Terraform/HCL
HCL (Hashicorp Configuration Language) is a config format used by a couple of Hashicorp's tools, notably [[http://www.terraform.io/][Terraform]].

#+begin_src emacs-lisp
  (use-package terraform-mode
    :mode "\\.tf\\'")
#+end_src
*** Markdown
A lot of people write Markdown. I don't know why they would do that when org-mode exists, but hey. Guess some people just haven't seen the light yet. Oh well.

#+begin_src emacs-lisp :tangle yes
  (use-package markdown-mode
    :mode ("\\.md\\'" . gfm-mode))
#+end_src

*** Data
JSON.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (srxl/fix-brace-indentation 'json-ts-mode "{" "[")
#+end_src

YAML.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))
#+end_src

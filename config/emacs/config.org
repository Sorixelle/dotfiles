#+title: srxl's Emacs Configuration
#+author: Ruby Iris Juric
#+email: ruby@srxl.me
#+description: My personal Emacs configuration, as a Literate Org-Mode document
#+startup: overview indent
#+property: header-args :noweb no-export

Hello, reader.

Welcome to my Emacs configuration.

You're probably here because you wish to glean knowledge of the arcane and eldritch arts of the almighty Emacs Text Editing, List Processing, Electronic-Mail Reading, Tetris Playing Realm... or something like that.

Or you're me. Could be that too.

Either way, no matter what brings you here, I hope you find whatever it was that your soul was searching for.

Maybe you find something you didn't even know you wanted. If so, awesome!

Maybe this is useless to you. That's cool too. First step to knowing what you need, is knowing what you don't need.

Pretty sure some old wise guy said that at some point.

Or maybe I'm making this up. I don't know.

Maybe I should get on with the actual config. Yeah, good idea. Let's do that.

* The basics
** In the beginning...
Alright, let's start by getting the very basics down. We'll start by enabling [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][lexical binding]] for this file, so that we avoid any Certified Weirdness that comes with dynamic binding.

#+begin_src emacs-lisp :tangle yes
  ;;; config.el -*- lexical-binding: t -*-
#+end_src

Cool. Now, in case you didn't know, I use [[https://nixos.org/][NixOS]] as my operating system, and I have a [[https://github.com/Sorixelle/dotfiles/][hella fancy setup]] for managing every single little piece of my machines. Including Emacs. I've written a [[https://github.com/Sorixelle/dotfiles/blob/master/home/modules/emacs.nix][cool little module]] to expose some parts of that configuration to Emacs in the form of an additional variables file. Let's load that in now.

#+begin_src emacs-lisp :tangle yes
  (load-file (concat user-emacs-directory "config-vars.el"))
#+end_src

** Setting expectations
Ok, let's start actually setting some Emacs options. First thing we'll do is disable the startup splash and clear the scratch buffer. We want a clean slate when we start up.

#+begin_src emacs-lisp :tangle yes
  (setq inhibit-startup-screen t
        initial-scratch-message nil)
#+end_src

Next, let's change every "yes or no" prompt to be "y or n". Less typing for me. Oh, and don't make graphical popups for those. I'd rather not use my mouse, thanks.

#+begin_src emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq use-dialog-box nil)
#+end_src

Now that we have that, we'll ask one of those questions whenever we go to close Emacs. Can never be too safe.

#+begin_src emacs-lisp :tangle yes
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Let's get rid of those gaudy UI elements. Who needs a toolbar or a scrollbar when you have a keyboard and every keybinding you could ever want?

#+begin_src emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (fringe-mode 1)
#+end_src

We'll start up all Emacs windows fullscreen, so that we have as much space as possible to wreak havoc on the world. Or at least write some words in a file.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

While we're doing windows - opening a file in macOS from the Finder seems to always create a new frame, which is really annoying. Stop doing that.

#+begin_src emacs-lisp :tangle yes
  (when (eq window-system 'ns)
    (setq ns-pop-up-frames nil))
#+end_src

Automatically reload buffers when their underlying files change on the disk, when other rude tools start yanking the carpet from under me.

#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
#+end_src

Make sure all code files have their syntax highlighting enabled.

#+begin_src emacs-lisp :tangle yes
  (global-font-lock-mode 1)
#+end_src

Crank up Emacs' garbage collection limit to 20MB, so it doesn't run as often.

#+begin_src emacs-lisp :tangle yes
  (setq gc-cons-threshold 20000000)
#+end_src

Don't open the Warnings buffer whenever there's a native compilation warning. It's annoying and gets in my face.

#+begin_src emacs-lisp :tangle yes
  (setq native-comp-async-report-warnings-errors 'silent)
#+end_src

Write customizations to it's own, dedicated file. Writing to =init.el= isn't going to fly under NixOS, since it manages that file with a symlink.

#+begin_src emacs-lisp :tangle yes
  (setq custom-file (concat user-emacs-directory "customizations.el"))
  (load-file custom-file)
#+end_src

And, last but not least... STOP MAKING NOISES

#+begin_src emacs-lisp :tangle yes
  (setq ring-bell-function 'ignore)
#+end_src

** File editing bits and bobs
Trailing whitespace is yucky. Except for trailing newlines at the end of a file though - those are good. We want those. Let's make that happen.

#+begin_src emacs-lisp :tangle yes
  (setq require-final-newline 'visit-save)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Backups and auto-save files are an absolute godsend. They've saved my ass /so/ many times. But the default behaviour of just cramming them next to the actual file is really annoying, especially for version control. We'll adjust their behaviour a little bit, so that:

- Backup files go to =~/.emacs.d/backups=
- Autosave files go to =~/.emacs.d/auto-saves=
- Some extra options are tweaked (see comments)

#+begin_src emacs-lisp :tangle yes
  (setq backup-by-copying t    ; Keep symlinks intact
        version-control t      ; Make sure backups are numbered
        delete-old-versions t  ; Always delete old backups
        kept-new-versions 10   ; Keep the last 10 backups
        kept-old-versions 0    ; Don't worry about keeping initial ones
        auto-save-interval 50) ; Autosave every 50 characters typed

  (let ((backup-dir (concat user-emacs-directory "backups/"))
        (auto-save-dir (concat user-emacs-directory "auto-saves/"))
        (max-file-size (* 5 1024 1024))) ; 2 MB
    (if (not (file-exists-p backup-dir))
        (make-directory backup-dir))
    (if (not (file-exists-p auto-save-dir))
        (make-directory auto-save-dir))
    (setq backup-directory-alist `(("" . ,backup-dir))
          auto-save-file-name-transforms `((".*" ,auto-save-dir t))))
#+end_src

Lockfiles though - those suck. I don't need those. Go away. You smell.

#+begin_src emacs-lisp :tangle yes
  (setq create-lockfiles nil)
#+end_src

Typing over text doesn't really work the way you'd expect it to in Emacs by default, but luckily there's a minor mode to fix that.

#+begin_src emacs-lisp :tangle yes
  (delete-selection-mode 1)
#+end_src

Single space after full stops. Come on. Why isn't this the default?

#+begin_src emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)
#+end_src

Indent with spaces, not tabs. Come on. Why isn't this the default?

#+begin_src emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
#+end_src

2 space indents. Come on. Why isn't thi

#+begin_src emacs-lisp :tangle yes
  (setq-default tab-width 2)
#+end_src

Default line length is 80 characters. Wrap lines to that length.

#+begin_src emacs-lisp :tangle yes
  (setq-default fill-column 80)
#+end_src

** Package preparation
There are much smarter people out there, who can write way better and much cooler stuff with Emacs than I can. We can ~steal~ leverage their work through the help of a package manager. My package manager of choice is [[https://github.com/raxod502/straight.el][straight.el]]. I like it for a few reasons:

- Grabs packages straight from Git, so I have the latest and greatest versions
- Loads packages declaratively - don't load anything I don't tell it to
- Lets me hack on packages if I need to, and I often find myself needing to

Let's set it up. I'll pinch that little block from their repo's README.
#+begin_src emacs-lisp :tangle yes
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

While we're here, let's bring in another cool tool for managing packages: [[https://github.com/jwiegley/use-package][use-package]]. This little macro is wonderful for organizing package configuration in once central place. It's even got integration with straight.el, so it can install the packages too.
#+begin_src emacs-lisp :tangle yes
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

And while we're here, let's set up our first package - [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]. This ensures that =exec-path= is correctly setup on macOS, because macOS is really dumb and stupid and doesn't know what it's doing.
#+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :custom
    (exec-path-from-shell-variables '("PATH" "MANPATH" "NIX_PATH"))
    :config
    (exec-path-from-shell-initialize))
#+end_src

* Moving around and doing things
** A heretical interface
I love Vim keybindings. Modal editing just makes so much sense to me. Being able to yank lines, move between words, easily navigate through my documents with simple, (usually) mnemonic keybindings feels so nice. Over here in Emacs-land, we've got a package aptly titled [[https://github.com/emacs-evil/evil][Evil]]... y'know, because Vim keybindings... editor holy wars... Vim is evil if you're in the Emacs camp...

Meh, whatever. Let's get it set up.
#+begin_src emacs-lisp :tangle yes
  (use-package evil
    :init
    <<EVIL-INIT>>
    :config
    <<EVIL-CONFIG>>)
#+end_src

First thing that needs to be done, is enabling =evil-mode=. That'll get us all our keybindings active.
#+begin_src emacs-lisp :noweb-ref EVIL-CONFIG
  (evil-mode 1)
#+end_src

We'll also add [[https://github.com/emacs-evil/evil-collection][evil-collection]], which extends Evil's keybindings to a few other modes and extra packages.
#+begin_src emacs-lisp :tangle yes
  (use-package evil-collection
    :config
    (evil-collection-init)
    <<EVILCOLLECTION-CONFIG>>)
#+end_src

But first - evil-collection requires =evil-want-keybinding= to be set to =nil= before Evil is loaded.
#+begin_src emacs-lisp :noweb-ref EVIL-INIT
  (setq evil-want-keybinding nil)
#+end_src

Tell evil-collection NOT to eat my =TAB= binding in Outline mode (and Org mode by extension).
#+begin_src emacs-lisp :noweb-ref EVILCOLLECTION-CONFIG
  (setq evil-collection-outline-bind-tab-p t)
#+end_src

** Managing the keyboard buttons
The keyboard is the best interface to Emacs. Keybindings can do everything. Although, managing keybindings can be a bit tricky. Luckily, [[https://github.com/noctuid/general.el][general.el]] has us covered there. General provides a nice interface for managing keybindings, especially when it comes to things like enabling bindings only in certain Evil states.

#+begin_src emacs-lisp :tangle yes
  (use-package general)
#+end_src

Another useful tool is [[https://github.com/abo-abo/hydra/][Hydra]], which creates transient layers with a set of keybindings defined, that deactivates when another key is pressed. It's hard to describe. Go check out that link, they describe it there better than I could.

#+begin_src emacs-lisp :tangle yes
  (use-package hydra)
#+end_src

Finding all these keybindings can be a pain. Luckily we have [[https://github.com/justbur/emacs-which-key][which-key]] to help us with that. It shows us a list of all avaliable commands when we hit a prefix, such as =C-c=. Useful for identifying just what the hell the "switch buffer" command is. Was is =C-c C-b=? =C-c b=? Some other insane combination? I don't know, you tell me.

#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :config
    (which-key-mode 1))
#+end_src

Because I might use EXWM in this config (more on that later), I need to be able to set global keys for EXWM, in case I want to be able to use those keybindings when in graphical windows. The way my Nix config is managed, I can toggle it on and off in there, and have the state exposed to Emacs through the variable =srxl/use-exwm=. We'll define a helper function for making such global keybindings, that does 2 things for us:
- Use =exwm-input-set-key= if EXWM is in use, or =general-def= otherwise
- Use Super as the prefix only when we're using EXWM, and fallback to Meta otherwise. Super isn't always guarranteed to work outside of EXWM, since other window managers have a tendency to eat those key events.

#+begin_src emacs-lisp :tangle yes
  (defun srxl/define-global-key (key cmd)
    "Binds CMD, using `exwm-input-set-key' to s-KEY globally if EXWM is in use,
  or using `general-def' to M-KEY otherwise."
    (if srxl/use-exwm
        (exwm-input-set-key (kbd (format "s-%s" key)) cmd)
      (general-def (format "M-%s" key) cmd)))
#+end_src

** Window navigation
Navigating between windows is something I do in Emacs /constantly/. Especially when I use EXWM, which I'll get to later in this config. Keybindings to help me do that would be nice. Let's start off with a simple one - moving between windows. For that, we'll use the Vim arrows to move between windows.

Since these are keybindings we want to be able to use from EXWM windows, we'll use that helpful little =srxl/define-global-key= function I defined earlier to define them.

#+begin_src emacs-lisp :noweb-ref POST-EXWM
  (srxl/define-global-key "h" 'windmove-left)
  (srxl/define-global-key "j" 'windmove-down)
  (srxl/define-global-key "k" 'windmove-up)
  (srxl/define-global-key "l" 'windmove-right)
#+end_src

Now for moving windows around. Surprisingly, Emacs doesn't seem to have a good built-in equivalent of =windmove= for swapping windows. Luckily, [[https://github.com/lukhas/buffer-move][buffer-move]] provides this functionality for us. We'll use the same keybindings as above, but also hold Shift for moving windows.

#+begin_src emacs-lisp :noweb-ref POST-EXWM
  (use-package buffer-move)
  (srxl/define-global-key "H" 'buf-move-left)
  (srxl/define-global-key "J" 'buf-move-down)
  (srxl/define-global-key "K" 'buf-move-up)
  (srxl/define-global-key "L" 'buf-move-right)
#+end_src

Looking good. But what if we want to do a whole bunch of window moving operations at once? Surely we don't have to keep holding down Super all the time. That would suck. Good thing we don't. This is where Hydra comes in handy - we can define a window management hydra that puts us in a "window management mode" indefinitely, until we're done with managing windows. Perfect!

We'll also add bindings for creating new windows through splits in here. Since making splits is something you would almost always do in combination with another window move or swap, it doesn't really need it's own separate binding. I also can't think of a nice standalone binding, so this is a good excuse.

#+begin_src emacs-lisp :noweb-ref POST-EXWM
  (defhydra srxl/window-management (:hint nil)
    "
  Window Management

  ^^Move:       ^^Swap:       ^^Create
  _h_: Left     _H_: Left     _s-l_: Left side
  _j_: Down     _J_: Down     _s-j_: Bottom side
  _k_: Up       _K_: Up       _x_:   Close
  _l_: Right    _L_: Right"
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)
    ("H" buf-move-left)
    ("J" buf-move-down)
    ("K" buf-move-up)
    ("L" buf-move-right)
    ("s-l" split-window-right)
    ("s-j" split-window-below)
    ("x" delete-window))

  (srxl/define-global-key "w" 'srxl/window-management/body)
#+end_src

Cool, windows are sorted - now we need some stuff for switching buffers. We'll keep it simple - =s-b= to search for a buffer.

#+begin_src emacs-lisp :noweb-ref POST-EXWM
  (srxl/define-global-key "b" 'counsel-switch-buffer)
#+end_src

** Searching and completing and filtering and
So, you expect me to just hit =M-x=, and know the exact name of the thing I'm looking for? Yeah, alright. I'm clueless. I don't know what things are called. Besides, even if I did, that's way too much typing. If only there was an autocompletion framework out there to make this easier...

Ok, ok. It's called [[https://github.com/abo-abo/swiper#ivy][Ivy]]. And [[https://github.com/abo-abo/swiper#counsel][Counsel]]. These two packages together give me a really nice, simple and lightweight autocompletion system for any =completing-read= task I may need.
#+begin_src emacs-lisp :tangle yes
  (use-package ivy
    :after flx
    :config
    (ivy-mode 1)
    <<IVY-CONFIG>>)

  (use-package counsel
    :after ivy
    :config
    (counsel-mode 1)
    <<COUNSEL-CONFIG>>)
#+end_src

Include recently accessed files in =ivy-switch-buffer= results.
#+begin_src emacs-lisp :noweb-ref IVY-CONFIG
  (setq ivy-use-virtual-buffers t)
#+end_src

Show the amount of avaliable completions in [square braces], because I like the look of it.
#+begin_src emacs-lisp :noweb-ref IVY-CONFIG
  (setq ivy-count-format "[%d] ")
#+end_src

Fuzzy search! Ivy leverages [[https://github.com/lewang/flx][flx]] to help sort the results in a meaningful way. Don't fuzzy search in =swiper= though, that gets really unusable.
#+begin_src emacs-lisp :noweb-ref IVY-CONFIG
  (setq ivy-re-builders-alist '((swiper . ivy--regex-plus)
                                (t . ivy--regex-fuzzy)))
#+end_src
#+begin_src emacs-lisp :tangle yes
  (use-package flx)
#+end_src

No initial search value - I don't always want ^ at the start of my searches.
#+begin_src emacs-lisp :noweb-ref IVY-CONFIG
  (setq ivy-initial-inputs-alist nil)
#+end_src

Rebind a couple of keys I think are pretty clunky in Ivy:
- =ivy-immediate-done= :: from =C-M-j= to =S-RET=
- =ivy-dispatching-done= :: from =M-o= to =C-RET=
#+begin_src emacs-lisp :noweb-ref IVY-CONFIG
  (general-def 'ivy-minibuffer-map
    "S-<return>" 'ivy-immediate-done
    "C-<return>" 'ivy-dispatching-done)
#+end_src

Also rebind =/= to =counsel-grep-or-swiper=. It's a really nice interface for searching files.
#+begin_src emacs-lisp :noweb-ref COUNSEL-CONFIG
  (general-def '(normal motion)
    "/" 'counsel-grep-or-swiper)
#+end_src

* ✨aesthetics✨
If I'm going to use Emacs as much as I do, I want to use something that's actually nice to look at. Default Emacs might be nice to some people... but not to me. Time to fix that up.

** Pretty letters
We'll start off by setting some nicer fonts. That's one of the things that's a part of my NixOS config, so we'll read the variables set from there.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'default-frame-alist `(font . ,(concat srxl/font-family-monospace " " srxl/font-size-monospace)))
  (set-face-attribute 'variable-pitch nil :family srxl/font-family-ui :height srxl/font-size-ui)
  (set-face-attribute 'fixed-pitch nil :family srxl/font-family-monospace :height (* 10 (string-to-number srxl/font-size-monospace)))
#+end_src

We're also going to define a face for a serif font. This'll get used later, for stuff like Org mode.

#+begin_src emacs-lisp :tangle yes
  (defface serif
    `((t (:inherit variable-pitch :family ,srxl/font-family-serif :height ,srxl/font-size-serif)))
    "Serif font.")
#+end_src

** Pretty colours
Default emacs burns my eyes. /hiss/. I'll take a nicer theme, courtesy of [[https://github.com/hlissner/emacs-doom-themes][doom-themes]]. They've got a whole bunch of really nice ones. Which one do I use? That's defined in my NixOS configuration. Go check that out if you really wanna know.

#+begin_src emacs-lisp :tangle yes
  (use-package all-the-icons)
  (use-package doom-themes
    :config
    (load-theme srxl/theme-name t)
    <<DOOMTHEMES-CONFIG>>)
#+end_src

** Pretty modeline
The mode line in Emacs is that little line at the bottom of the window that has all the status stuff, like filename... uh... man, the default mode line doesn't really have a lot of useful stuff in it, huh? Hmm.

I'm far too lazy to write my own mode line. Luckily, multiple people have done it for me, and I just need to pick the one I like. And I like [[https://github.com/seagle0128/doom-modeline][doom-modeline]]. It's got everything I could possibly want in a modeline, and it looks cool to boot. Let's get it going.

#+begin_src emacs-lisp :tangle yes
  (use-package doom-modeline
    :config
    <<DOOMLINE-CONFIG>>)
#+end_src

Make the modeline nice and thick.
#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (setq doom-modeline-height 32)
#+end_src

Enable =column-number-mode= so that we can get column number displayed in the modeline, along with the line number.

#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (column-number-mode 1)
#+end_src

And enable =display-time-mode= for a clock in there as well.

#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (display-time-mode 1)
#+end_src

And activate.

#+begin_src emacs-lisp :noweb-ref DOOMLINE-CONFIG
  (doom-modeline-mode 1)
#+end_src

* Emacs, my favourite word processor
[[https://orgmode.org/][org-mode]] might just be one of the most amazing programs ever made. Like, seriously. This thing is amazing. It's a markup language, a todo list, a calendar, a spreadsheet, Jupyter Notebook on sterioids... I could keep going on here, but that's probably not what you're here for. You're here to see me configure this delightful thing. And I'm not about to waste anymore time.

#+begin_src emacs-lisp :tangle yes
  (use-package org
    :config
    <<ORG-CONFIG>>)
#+end_src

#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

** Making documents look pretty
Monospaced text just doesn't quite do org-mode justice. This isn't code (well, not entirely) - it's a document! Let's make it look like one by using a fancy serif font. Check the NixOS config for which specific one it is.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-hook 'org-mode-hook (lambda () (progn
                                        (setq-local buffer-face-mode-face 'variable-pitch)
                                        (buffer-face-mode 1))))
#+end_src

Code should probably still be monospace though. That makes sense.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch)
#+end_src

So should tables, otherwise they look all ugly and misaligned.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+end_src

Make headings look a little prettier with [[https://github.com/sabof/org-bullets][org-bullets]].
#+begin_src emacs-lisp :tangle yes
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+end_src

And make them a bit more distinct at each level, by setting different sizes for them.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (set-face-attribute 'org-document-title nil :height 1.5)
  (set-face-attribute 'org-level-1 nil :height 1.5)
  (set-face-attribute 'org-level-2 nil :height 1.25)
  (set-face-attribute 'org-level-3 nil :height 1.125)
  (set-face-attribute 'org-level-4 nil :height 1.1)
#+end_src

Don't worry about showing the symbols around things like *bold*, /italic/ or =inline code=.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (setq org-hide-emphasis-markers t)
#+end_src

But add a function and a keybinding to toggle them, in case we want them.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (defun srxl/org-toggle-emphasis-markers ()
    "Toggle the visibility of emphasis markers in Org mode buffers."
    (interactive)
    (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
    (font-lock-fontify-buffer))

  ;; TODO: finalize binding
  (general-def 'org-mode-map
    "C-c t" 'srxl/org-toggle-emphasis-markers)
#+end_src

doom-themes from earlier includes some stuff to tidy up Org visuals a little bit.
#+begin_src emacs-lisp :noweb-ref DOOMTHEMES-CONFIG
  (doom-themes-org-config)
#+end_src

** Editing trickery
As part of writing these documents, I create a lot of emacs-lisp source blocks in Org. Like, a lot. A faster way to create those is definitely in order. Luckily, =org-structure-template-alist= comes in handy for us to add whatever shortcust we want for producing blocks. Let's add a shortcut for making an emacs-lisp source block.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
#+end_src

To make things even faster, we can use Org Tempo to summon a block, just by typing =<el= and hitting TAB.
#+begin_src emacs-lisp :noweb-ref ORG-CONFIG
  (require 'org-tempo)
#+end_src

* Emacs, my favourite IDE
Yeah, this is the one everyone knows Emacs for. Code editor! That's the main one everyone uses Emacs for. And for good reason - it does a damn good job of editing code. Although, it does need a little assistance to get it off the ground in that regard. Let's give it a hand.

** General
First, a few general bits and pieces that we want to have when editing code.

Show line numbers in all code files. Pretty much every programming mode derives from =prog-mode=, so we can hook into that.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook 'linum-mode)
#+end_src

Keeping things like quotation marks for strings, and parentheses balanced is really important for code edititng. [[https://github.com/Fuco1/smartparens][Smartparens]] is a good option for this. So we'll use it.
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :config
    (require 'smartparens-config)
    (smartparens-global-mode))
#+end_src

** Autocomplete
First off, let's get some autocomplete capability in here. We gotta have that - what's an IDE without autocomplete? Although, this doesn't provide language-specific completions, just the UI for autocompletion. We'll get to that in a bit.

[[https://github.com/minad/corfu][Corfu]] is a super neat little library that builds off =completion-at-point= to provide a nice little autocomplete box.
#+begin_src emacs-lisp :tangle yes
  (use-package corfu
    :config
    <<CORFU-CONFIG>>)
#+end_src

Like most editors, we want the autocomplete options to appear right after we've finished typing, without a delay.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-auto t
        corfu-auto-delay 0
        corfu-auto-prefix 0)
#+end_src

We also want to cycle back to the top of the list if we try to go past the end.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-cycle t)
#+end_src

Don't select any completion by default...
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (setq corfu-preselect-first nil)
#+end_src

...because we want to hit Tab to cycle through completions, and just fill the one we land on.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (general-def 'corfu-map
    "TAB" 'corfu-next
    [tab] 'corfu-next
    "S-TAB" 'corfu-previous
    [backtab] 'corfu-previous)
#+end_src

Use fuzzy searching in completions.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (add-to-list 'completion-styles 'flex)
#+end_src

Being able to see the documentation of items I've selected is nice. [[https://github.com/galeo/corfu-doc][corfu-doc]] can do that for us.
#+begin_src emacs-lisp :tangle yes
  (use-package corfu-doc
    :hook (corfu-mode . corfu-doc-mode))
#+end_src

[[https://github.com/jdtsmith/kind-icon][kind-icon]] is another package that will give us little icons next to competions, kinda like how VSCode does it. It looks pretty. I like it.
#+begin_src emacs-lisp :tangle yes
  (use-package kind-icon
    :config
    <<KIND-ICON-CONFIG>>)
#+end_src

Set the default face for icons to be the one corfu uses, so that kind-icon can compute it's background colours correctly.
#+begin_src emacs-lisp :noweb-ref KIND-ICON-CONFIG
  (setq kind-icon-default-face 'corfu-default)
#+end_src

Tell Corfu to use kind-icon.
#+begin_src emacs-lisp :noweb-ref KIND-ICON-CONFIG
  (add-to-list 'corfu-margin-formatters 'kind-icon-margin-formatter)
#+end_src

Aaaaaaaaand enable.
#+begin_src emacs-lisp :noweb-ref CORFU-CONFIG
  (global-corfu-mode 1)
#+end_src

** Project management
When I'm working in projects, having some keybinds and commands to quickly get around and run some local dev servers or whatever is really useful. [[https://docs.projectile.mx/projectile/index.html][Projectile]] gives a whole lot of that.

Now that we have that function setup, let's bring Projectile in.
#+begin_src emacs-lisp :tangle yes
  <<projectile-pre>>
  (use-package projectile
    :config
    <<projectile-config>>
    (projectile-mode 1))
#+end_src

Projectile is able to use ripgrep to search in projects, which is awesome - with the caveat that we need to bring in a supporting package.
#+begin_src emacs-lisp :tangle yes
  (use-package rg
    :after projectile)
#+end_src

And also with the caveat that it needs to run in a POSIX-compliant shell. I use Fish on most of my machines, so that's not gonna fly. We'll make sure Emacs uses a standard shell instead.
#+begin_src emacs-lisp :noweb-ref projectile-pre
  (setq shell-file-name "/bin/sh")
#+end_src

I generally tend to keep all my projects in a single folder. Since that can be different on different machines, it's defined in =config-vars.el=. Giving that path to Projectile can help it to auto-detect projects.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (setq projectile-project-search-path (list srxl/project-dir))
#+end_src

When calling functions that run project commands, like =projectile-compile-project=, Projectile shows the command's output in a Compilation Mode buffer. By default, it doesn't handle ANSI colors correctly, but there's a function we can add to =compilation-filter-hook= to do this for us.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+end_src

Let's add some keybindings to get started here. We're going to use the same =SPC= leader key pattern that Emacs frameworks like Doom and Spacemacs use - I'm a fan of it, makes things really easy to access while working in a project buffer. Less having to hold =C-whatever= as well, which is always nice. Using General, which we setup earlier, we can make a /definer/ function, that acts as a shortcut to adding keys under a prefix, and in specific Evil states.
#+begin_src emacs-lisp :noweb-ref projectile-pre
  (general-create-definer srxl/def-leader-key
    :states '(normal motion emacs)
    :prefix "SPC")
#+end_src

One thing to note though - Evil's motion state defines =SPC= as moving point forward, which conflicts with this leader key definition. We'll have to remove that before we can get anywhere.
#+begin_src emacs-lisp :noweb-ref projectile-pre
  (general-unbind 'motion "SPC")
#+end_src

And now, keybindings.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (srxl/def-leader-key
    "b" '(projectile-switch-to-buffer :wk "Switch buffer")
    "f" '(projectile-find-file :wk "Find file")
    "s" '(projectile-switch-project :wk "Switch project")
    "x" '(projectile-kill-buffers :wk "Close project")
    "/" '(projectile-ripgrep :wk "Grep project")

    "r" '(:ignore t :wk "Run command...")
    "r b" '(projectile-package-project :wk "Build")
    "r c" '(projectile-compile-project :wk "Compile")
    "r i" '(projectile-install-project :wk "Install")
    "r s" '(projectile-configure-project :wk "Configure")
    "r t" '(projectile-test-project :wk "Test"))
#+end_src

Other bindings will be coming in the following sections.

** File exploring
Next, we'll get outselves a file explorer, by way of [[https://github.com/Alexander-Miller/treemacs][Treemacs]]. It's a fully-featured file tree sidebar, just like you'd have in every IDE.

The project follow mode seems to have some issues with byte compilation, so we won't byte-compile Treemacs.
#+begin_src emacs-lisp :tangle yes
  <<TREEMACS-PRE>>
  (use-package treemacs
    :straight (:build (:not compile))
    :custom
    <<TREEMACS-CUSTOM>>
    :config
    <<TREEMACS-CONFIG>>)
#+end_src

Grab the Evil extensions, otherwise navigating through that tree is gonna be no fun at all.
#+begin_src emacs-lisp :tangle yes
  (use-package treemacs-evil)
#+end_src

Ensure that Treemacs follows the project we're currently in. I don't have much use for the workspaces feature it provides - I prefer to work in one project at a time.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-project-follow-mode 1)
#+end_src

Watch for filesystem changes.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-filewatch-mode 1)
#+end_src

Colour nodes in the tree based on Git status.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (treemacs-git-mode 'deferred)
#+end_src

Set the default file opening behaviour to open the file in the last visited window.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CUSTOM
  (treemacs-default-visit-action 'treemacs-visit-node-in-most-recently-used-window)
#+end_src

doom-themes has some nice icon themes for Treemacs. We'll use those icons.
#+begin_src emacs-lisp :noweb-ref DOOMTHEMES-CONFIG
  (setq doom-themes-treemacs-theme "doom-atom")
  (doom-themes-treemacs-config)
#+end_src

Bind =SPC .= to toggle Treemacs on and off.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (srxl/def-leader-key
    "." '(treemacs :wk "Toggle Treemacs"))
#+end_src

I'm not a fan of having Treemacs open all the time. It takes up space when I'm editing files, and I end up using my mouse to navigate between files more often than I'd like when it's left open. To solve this, we'll first define a helper function to close the Treemacs window if it's opened.
#+begin_src emacs-lisp :noweb-ref TREEMACS-PRE
  (defun srxl/close-treemacs-if-open (&rest _)
    "Close the Treemacs window if it is open. Otherwise, do nothing."
    (when-let (win (treemacs-get-local-window))
      (delete-window win)))
#+end_src

Then, we'll add advice to the =treemacs-visit= class of functions, so that the window gets closed when a file is selected. Much cleaner view for code editing.
#+begin_src emacs-lisp :noweb-ref TREEMACS-CONFIG
  (advice-add 'treemacs-visit-node-in-most-recently-used-window :after 'srxl/close-treemacs-if-open)
  (advice-add 'treemacs-visit-node-vertical-split :after 'srxl/close-treemacs-if-open)
  (advice-add 'treemacs-visit-node-horizontal-split :after 'srxl/close-treemacs-if-open)
#+end_src

** Version control
Remember how I said org-mode might be one of the best programs ever made? [[https://magit.vc/][Magit]] is like, tied. At least second place. Magit is, without a doubt, the single most comprehensive Git interface I have ever seen. I haven't found a task I can't do in Magit yet. It's amazing. Seriously, if you use Emacs, and manage Git projects, but aren't using Magit, you're missing out big time.
#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :config
    <<MAGIT-CONFIG>>)
#+end_src

Open the Magit interface with =SPC v=.
#+begin_src emacs-lisp :noweb-ref MAGIT-CONFIG
  (srxl/def-leader-key
    "v" '(magit-status :wk "View Git status"))
#+end_src

Treemacs has some integration with Magit, to get the Git status highlighting of files in sync.
#+begin_src emacs-lisp :tangle yes
  (use-package treemacs-magit
    :after (treemacs magit))
#+end_src

** Integrated terminal
[[https://github.com/akermu/emacs-libvterm][emacs-libvterm]] is probably the most fully-featured terminal emulator out there. It provides a really nice integration experience with Emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package vterm
    :config
    <<VTERM-CONFIG>>)
#+end_src

Use the shell-provided title in the buffer name.
#+begin_src emacs-lisp :noweb-ref VTERM-CONFIG
  (setq vterm-buffer-name-string "vterm (%s)")
#+end_src

[[https://github.com/kyagi/shell-pop-el][shell-pop]] is a tool that gives us a popup terminal that behaves a lot like the integrated one in VSCode.
#+begin_src emacs-lisp :tangle yes
  (use-package shell-pop
    :config
    <<SHELLPOP-CONFIG>>)
#+end_src

Typically, if I'm in a project, I want a terminal to open in the root of that project, not somewhere in the middle of the source code tree. We can write a function to check if we're in a project, and if so, open a project in the project root - otherwise, just use the current =default-directory=.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (defun srxl/open-vterm-in-project (&optional name)
    "Create a new vterm buffer named NAME.

  If in a project, start the shell in `projectile-project-root'. Otherwise, start
  it in `default-directory'."
    (let ((default-directory (or (projectile-project-root) default-directory)))
      (message default-directory)
      (vterm name)))
#+end_src

We'll use that function to open terminal buffers in shell-pop.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (custom-set-variables
   '(shell-pop-shell-type '("vterm" "vterm-sp" (lambda () (srxl/open-vterm-in-project "vterm-sp")))))
#+end_src

Don't forget to tell shell-pop to not automatically change to the directory of the buffer we called it from, because that screws with the function we just wrote.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (setq shell-pop-autocd-to-working-dir nil)
#+end_src

Since we had to overwrite the default shell during the Projectile setup, we'll need to restore it back to what we want for vterm and shell-pop. If it's defined in =config-vars.el=, we'll use that - otherwise just leave it alone.
#+begin_src emacs-lisp :noweb-ref VTERM-CONFIG
  (when (boundp 'srxl/shell-executable)
    (setq vterm-shell srxl/shell-executable
          shell-pop-term-shell srxl/shell-executable))
#+end_src

Use =SPC t= to open the terminal.
#+begin_src emacs-lisp :noweb-ref SHELLPOP-CONFIG
  (srxl/def-leader-key
    "t" '(shell-pop :wk "Open terminal"))
#+end_src

** Language Server Protocol
And now we get to the special sauce - LSP support. [[https://github.com/joaotavora/eglot][Eglot]] is a really cool, language-agnostic package that soups up the facilities Emacs already has for things like autocomplete (=completion-at-point=), jump to definition (=xref-find-definitions=) and diagnostics (=flymake-mode=).

#+begin_src emacs-lisp :tangle yes
  (use-package eglot)
#+end_src

If Eglot started successfully, enable flymake for the buffer.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'eglot-server-initialized-hook 'flymake-mode)
#+end_src

Eglot relies on the built-in project.el for project detection. We can make Projectile use the same logic project.el does, just to keep things consistent.
#+begin_src emacs-lisp :noweb-ref projectile-config
  (defun srxl/projectile-get-current-project (dir)
    "Get the root of the project at DIR with project.el's `project-current'."
    (when-let (proj-dir (cdr (project-current nil dir)))
      (expand-file-name proj-dir)))

  (setq projectile-project-root-functions '(srxl/projectile-get-current-project))
#+end_src

** Direnv integration
[[https://direnv.net/][Direnv]] is a really useful tool for setting environments per directory. It's a total godsend when working with Nix projects, since it means I can just =cd= into a directory and get that shell right away. =direnv-mode= provides that functionality for Emacs itself, so that it can call out to programs in a Nix shell. As a heavy Nix user, I can't live without it.
#+begin_src emacs-lisp :tangle yes
  (use-package direnv
    :config
    (direnv-mode))
#+end_src

** Languages
Now for all the language specific fun.

*** Nix
I use [[https://nixos.org/][Nix]] and NixOS extensively. Being able to declaratively manage system configurations, project environments, and even remote systems is just /so damn good/. I spend a lot of time editing Nix expressions as a result, so we should make sure Emacs gives me a good editing experience here.

[[https://github.com/NixOS/nix-mode][nix-mode]] provides syntax highlighting for Nix files. We'll also make sure Eglot gets enabled for them.
#+begin_src emacs-lisp :tangle yes
  (use-package nix-mode
    :mode "\\.nix\\'"
    :hook (nix-mode . eglot-ensure))
#+end_src

*** Web Markup
There's a lot of languages used on the web. HTML, CSS, JS, the infinite amount of templating frameworks every server-side MVC framework they just had to have their own one for... Surely we can't support them all, right? Maybe not all, but [[https://web-mode.org/][web-mode]] supports a hell of a lot of them.
#+begin_src emacs-lisp :tangle yes
  (use-package web-mode
    :mode ("\\.html\\'"
           "\\.\\(?:le\\|sa\\|sc\\|c\\)ss\\'"
           "\\.heex\\'")
    :config
    <<WEB-CONFIG>>)
#+end_src

2 space indentation.
#+begin_src emacs-lisp :noweb-ref WEB-CONFIG
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-style-padding 2
        web-mode-script-padding 2)
#+end_src

Change the HTML tag autoclosing to "Auto-close on > and </".
#+begin_src emacs-lisp :noweb-ref WEB-CONFIG
  (setq web-mode-auto-close-style 2)
#+end_src

*** Javascript and Typescript
The lingua franca of the web. Like it or not, it's what we're stuck with, so we're gonna have to use it.

**** Javascript
For Javascript: js-mode. It's built-in, and has everything we need for plain-old Javascript files.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[mc]?js\\'" . js-mode))
#+end_src

Indent with 2 spaces, not 4.
#+begin_src emacs-lisp :tangle yes
  (setq js-indent-level 2)
#+end_src

Make sure LSP is running is JS buffers.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'js-mode-hook 'eglot-ensure)
#+end_src

**** Typescript
[[https://github.com/emacs-typescript/typescript.el][typescript-mode]] is the way to go for editing Typescript files.
#+begin_src emacs-lisp :tangle yes
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . eglot-ensure)
    :config
    <<TS-CONFIG>>)
#+end_src

As with Javascript - indent with 2 spaces, not 4.
#+begin_src emacs-lisp :noweb-ref TS-CONFIG
  (setq typescript-indent-level 2)
#+end_src

**** JSX/TSX
=js-mode= and =typescript-mode= don't have JSX/TSX support built in. For that, we'll define modes derived from =web-mode= instead, which has support for them built in, and use it for those files. The derived mode is useful for distinguishing files from other =web-mode= types, like HTML or CSS.

#+begin_src emacs-lisp :tangle yes
  (define-derived-mode javascript-jsx-mode web-mode "JavaScript (JSX)")
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . javascript-jsx-mode))

  (define-derived-mode typescript-tsx-mode web-mode "TypeScript (TSX)")
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-tsx-mode))
#+end_src

Setup LSP support for these new modes, as well.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'javascript-jsx-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '(javascript-jsx-mode . ("typescript-language-server" "--stdio")))

  (add-hook 'typescript-tsx-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '(typescript-tsx-mode . ("typescript-language-server" "--stdio")))
#+end_src

**** JS Frameworks
Some JS frameworks are special and have their own file types. Time to get those set up as well, I guess.

***** Vue
For Vue - [[https://github.com/AdamNiederer/vue-mode][vue-mode]]. Particularly, a fork of it that fixes support for Vue 3's =<script setup>=. Hopefully [[https://github.com/AdamNiederer/vue-mode/pull/115][the PR]] gets merged soon, but considering the commit history on that repo... I'm not holding my breath.
#+begin_src emacs-lisp :tangle yes
  (use-package vue-mode
    :mode "\\.vue\\'"
    :straight (vue-mode :type git :host github :repo "garyo/vue-mode" :branch "script-setup-support")
    :config
    <<VUE-CONFIG>>)
#+end_src

Get rid of that annoying background face. It's a byproduct of mmm-mode, which vue-mode uses to provide syntax highlighting for the different language sections of a Vue component.
#+begin_src emacs-lisp :noweb-ref VUE-CONFIG
  (add-hook 'mmm-mode-hook (lambda ()
                             (set-face-background 'mmm-default-submode-face nil)))
#+end_src

Setup LSP support using Volar. Annoyingly, Volar is a bit of a special language server, and need some extra configuration on Eglot's side to get going. I'll upstream all this to Eglot soon, don't worry.
#+begin_src emacs-lisp :noweb-ref VUE-CONFIG
  (defclass eglot-volar (eglot-lsp-server) ()
    :documentation "Volar Language Server for Vue")

  (cl-defmethod eglot-initialization-options ((server eglot-volar))
    "Required initialization options for Volar"
    `(:typescript
      (:serverPath ,(expand-file-name (concat (project-root (project-current)) "node_modules/typescript/lib/tsserverlibrary.js")))
      :languageFeatures
      (:references
       t
       :definition t
       :typeDefinition t
       :hover t
       :rename t
       :signatureHelp t
       :completion (:defaultTagNameCase "both" :defaultAttrNameCase "kebabCase")
       :documentHighlight t
       :workspaceSymbol t
       :codeAction t
       :diagnostics t)
      :documentFeatures
      (:documentSymbol t)))

  (add-to-list 'eglot-server-programs '(vue-mode . (eglot-volar "volar-server" "--stdio")))
#+end_src

***** Svelte
For Svelte, we'll just use web-mode. Told you it supports a hell of a lot of template languages. We'll do a similar thing we did for JSX/TSX so that we can distinguish a Svelte file from any old web-mode file.
#+begin_src emacs-lisp :tangle yes
  (define-derived-mode svelte-mode web-mode "Svelte")
  (add-to-list 'auto-mode-alist '("\\.svelte\\'" . svelte-mode))
#+end_src

And LSP setup.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'svelte-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '(svelte-mode . ("svelteserver" "--stdio")))
#+end_src

*** BEAM (Erlang/Elixir)
The land of just letting it fail.

**** Elixir
Erlang with a modern flair.

#+begin_src emacs-lisp :tangle yes
  (use-package elixir-mode
    :mode "\\.exs?\\'"
    :hook (elixir-mode . eglot-ensure)
    :config
    <<ELIXIR-CONFIG>>)
#+end_src

Nix's packaged Elixir language server renames the binary to a much more sane =elixir-ls= instead of the weird =language-server.sh=. We'll need to let Eglot know about that difference though.
#+begin_src emacs-lisp :noweb-ref ELIXIR-CONFIG
    (add-to-list 'eglot-server-programs '(elixir-mode "elixir-ls"))
#+end_src

*** Markdown
A lot of people write Markdown. I don't know why they would do that when org-mode exists, but hey. Guess some people just haven't seen the light yet. Oh well.

#+begin_src emacs-lisp :tangle yes
  (use-package markdown-mode
    :mode ("\\.md\\'" . gfm-mode))
#+end_src

*** Data
JSON.
#+begin_src emacs-lisp :tangle yes
  (use-package json-mode
    :mode "\\.json\\'")
#+end_src

YAML.
#+begin_src emacs-lisp :tangle yes
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")
#+end_src

* Emacs, my favourite window manager
TODO: write some shit here

#+begin_src emacs-lisp :tangle yes
  (use-package exwm
    :if srxl/use-exwm
    :custom
    <<EXWM-CUSTOM>>
    :config
    <<EXWM-CONFIG>>)

  <<POST-EXWM>>
#+end_src

I'd like 9 workspaces by default. One for each number.

#+begin_src emacs-lisp :noweb-ref EXWM-CUSTOM
  (exwm-workspace-number 10)
#+end_src

We'll use a little hook to automatically set the buffer title to the name of the application running in there.

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
#+end_src

Bind a couple keys to be used in EXWM windows:
- =s-r= :: Go back to line-mode
- =s-SPC= :: Open an app launcher
- =s-q= :: Quit an app
- =s-RET= :: Open a terminal using vterm

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (setq exwm-input-global-keys
        `((,(kbd "s-r") . exwm-reset)
          (,(kbd "s-SPC") . counsel-linux-app)
          (,(kbd "s-q") . kill-this-buffer)
          (,(kbd "s-<return>") . vterm)))
#+end_src

We'll also generate a few keybindings for =s-<number>= to switch to that workspace.

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (nconc exwm-input-global-keys
         (mapcar (lambda (i)
                   `(,(kbd (format "s-%d" i)) .
                     (lambda ()
                       (interactive)
                       (exwm-workspace-switch-create ,i))))
                 (number-sequence 0 9)))
#+end_src

And for =s-S-<number>=, to move a buffer to that workspace.

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (nconc exwm-input-global-keys
         (cl-mapcar (lambda (k i)
                      `(,(kbd (format "s-%s" k)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-move-window ,i))))
                    '(")" "!" "@" "#" "$" "%" "^" "&" "*" "(")
                    (number-sequence 0 9)))
#+end_src

We'll enable EXWM's system tray support, so we can use those little icon thingies.

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
#+end_src

Finally, enable this Frankenstein's monster of a window manager.

#+begin_src emacs-lisp :noweb-ref EXWM-CONFIG
  (exwm-enable)
#+end_src
